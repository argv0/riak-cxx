// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riak_kv.proto

#ifndef PROTOBUF_riak_5fkv_2eproto__INCLUDED
#define PROTOBUF_riak_5fkv_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "riak.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_riak_5fkv_2eproto();
void protobuf_AssignDesc_riak_5fkv_2eproto();
void protobuf_ShutdownFile_riak_5fkv_2eproto();

class RpbGetClientIdResp;
class RpbSetClientIdReq;
class RpbGetReq;
class RpbGetResp;
class RpbPutReq;
class RpbPutResp;
class RpbDelReq;
class RpbListBucketsResp;
class RpbListKeysReq;
class RpbListKeysResp;
class RpbGetBucketReq;
class RpbGetBucketResp;
class RpbSetBucketReq;
class RpbMapRedReq;
class RpbMapRedResp;
class RpbIndexReq;
class RpbIndexResp;
class RpbContent;
class RpbLink;
class RpbBucketProps;

enum RpbIndexReq_IndexQueryType {
  RpbIndexReq_IndexQueryType_eq = 0,
  RpbIndexReq_IndexQueryType_range = 1
};
bool RpbIndexReq_IndexQueryType_IsValid(int value);
const RpbIndexReq_IndexQueryType RpbIndexReq_IndexQueryType_IndexQueryType_MIN = RpbIndexReq_IndexQueryType_eq;
const RpbIndexReq_IndexQueryType RpbIndexReq_IndexQueryType_IndexQueryType_MAX = RpbIndexReq_IndexQueryType_range;
const int RpbIndexReq_IndexQueryType_IndexQueryType_ARRAYSIZE = RpbIndexReq_IndexQueryType_IndexQueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpbIndexReq_IndexQueryType_descriptor();
inline const ::std::string& RpbIndexReq_IndexQueryType_Name(RpbIndexReq_IndexQueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpbIndexReq_IndexQueryType_descriptor(), value);
}
inline bool RpbIndexReq_IndexQueryType_Parse(
    const ::std::string& name, RpbIndexReq_IndexQueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpbIndexReq_IndexQueryType>(
    RpbIndexReq_IndexQueryType_descriptor(), name, value);
}
// ===================================================================

class RpbGetClientIdResp : public ::google::protobuf::Message {
 public:
  RpbGetClientIdResp();
  virtual ~RpbGetClientIdResp();
  
  RpbGetClientIdResp(const RpbGetClientIdResp& from);
  
  inline RpbGetClientIdResp& operator=(const RpbGetClientIdResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetClientIdResp& default_instance();
  
  void Swap(RpbGetClientIdResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetClientIdResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetClientIdResp& from);
  void MergeFrom(const RpbGetClientIdResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  
  // @@protoc_insertion_point(class_scope:RpbGetClientIdResp)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* client_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetClientIdResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetClientIdReq : public ::google::protobuf::Message {
 public:
  RpbSetClientIdReq();
  virtual ~RpbSetClientIdReq();
  
  RpbSetClientIdReq(const RpbSetClientIdReq& from);
  
  inline RpbSetClientIdReq& operator=(const RpbSetClientIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetClientIdReq& default_instance();
  
  void Swap(RpbSetClientIdReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbSetClientIdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetClientIdReq& from);
  void MergeFrom(const RpbSetClientIdReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  
  // @@protoc_insertion_point(class_scope:RpbSetClientIdReq)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* client_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbSetClientIdReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetReq : public ::google::protobuf::Message {
 public:
  RpbGetReq();
  virtual ~RpbGetReq();
  
  RpbGetReq(const RpbGetReq& from);
  
  inline RpbGetReq& operator=(const RpbGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetReq& default_instance();
  
  void Swap(RpbGetReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetReq& from);
  void MergeFrom(const RpbGetReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional uint32 r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);
  
  // optional uint32 pr = 4;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 4;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);
  
  // optional bool basic_quorum = 5;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 5;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);
  
  // optional bool notfound_ok = 6;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 6;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);
  
  // optional bytes if_modified = 7;
  inline bool has_if_modified() const;
  inline void clear_if_modified();
  static const int kIfModifiedFieldNumber = 7;
  inline const ::std::string& if_modified() const;
  inline void set_if_modified(const ::std::string& value);
  inline void set_if_modified(const char* value);
  inline void set_if_modified(const void* value, size_t size);
  inline ::std::string* mutable_if_modified();
  inline ::std::string* release_if_modified();
  
  // optional bool head = 8;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 8;
  inline bool head() const;
  inline void set_head(bool value);
  
  // optional bool deletedvclock = 9;
  inline bool has_deletedvclock() const;
  inline void clear_deletedvclock();
  static const int kDeletedvclockFieldNumber = 9;
  inline bool deletedvclock() const;
  inline void set_deletedvclock(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbGetReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();
  inline void set_has_if_modified();
  inline void clear_has_if_modified();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_deletedvclock();
  inline void clear_has_deletedvclock();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 pr_;
  ::std::string* if_modified_;
  bool basic_quorum_;
  bool notfound_ok_;
  bool head_;
  bool deletedvclock_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetResp : public ::google::protobuf::Message {
 public:
  RpbGetResp();
  virtual ~RpbGetResp();
  
  RpbGetResp(const RpbGetResp& from);
  
  inline RpbGetResp& operator=(const RpbGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetResp& default_instance();
  
  void Swap(RpbGetResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetResp& from);
  void MergeFrom(const RpbGetResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();
  
  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  
  // optional bool unchanged = 3;
  inline bool has_unchanged() const;
  inline void clear_unchanged();
  static const int kUnchangedFieldNumber = 3;
  inline bool unchanged() const;
  inline void set_unchanged(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbGetResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_unchanged();
  inline void clear_has_unchanged();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;
  bool unchanged_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutReq : public ::google::protobuf::Message {
 public:
  RpbPutReq();
  virtual ~RpbPutReq();
  
  RpbPutReq(const RpbPutReq& from);
  
  inline RpbPutReq& operator=(const RpbPutReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutReq& default_instance();
  
  void Swap(RpbPutReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutReq& from);
  void MergeFrom(const RpbPutReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional bytes vclock = 3;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 3;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  
  // required .RpbContent content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::RpbContent& content() const;
  inline ::RpbContent* mutable_content();
  inline ::RpbContent* release_content();
  
  // optional uint32 w = 5;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 5;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);
  
  // optional uint32 dw = 6;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 6;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);
  
  // optional bool return_body = 7;
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 7;
  inline bool return_body() const;
  inline void set_return_body(bool value);
  
  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);
  
  // optional bool if_not_modified = 9;
  inline bool has_if_not_modified() const;
  inline void clear_if_not_modified();
  static const int kIfNotModifiedFieldNumber = 9;
  inline bool if_not_modified() const;
  inline void set_if_not_modified(bool value);
  
  // optional bool if_none_match = 10;
  inline bool has_if_none_match() const;
  inline void clear_if_none_match();
  static const int kIfNoneMatchFieldNumber = 10;
  inline bool if_none_match() const;
  inline void set_if_none_match(bool value);
  
  // optional bool return_head = 11;
  inline bool has_return_head() const;
  inline void clear_return_head();
  static const int kReturnHeadFieldNumber = 11;
  inline bool return_head() const;
  inline void set_return_head(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbPutReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_return_body();
  inline void clear_has_return_body();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_if_not_modified();
  inline void clear_has_if_not_modified();
  inline void set_has_if_none_match();
  inline void clear_has_if_none_match();
  inline void set_has_return_head();
  inline void clear_has_return_head();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::RpbContent* content_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 pw_;
  bool return_body_;
  bool if_not_modified_;
  bool if_none_match_;
  bool return_head_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbPutReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutResp : public ::google::protobuf::Message {
 public:
  RpbPutResp();
  virtual ~RpbPutResp();
  
  RpbPutResp(const RpbPutResp& from);
  
  inline RpbPutResp& operator=(const RpbPutResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutResp& default_instance();
  
  void Swap(RpbPutResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbPutResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutResp& from);
  void MergeFrom(const RpbPutResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();
  
  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  
  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // @@protoc_insertion_point(class_scope:RpbPutResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_key();
  inline void clear_has_key();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;
  ::std::string* key_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbPutResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbDelReq : public ::google::protobuf::Message {
 public:
  RpbDelReq();
  virtual ~RpbDelReq();
  
  RpbDelReq(const RpbDelReq& from);
  
  inline RpbDelReq& operator=(const RpbDelReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbDelReq& default_instance();
  
  void Swap(RpbDelReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbDelReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbDelReq& from);
  void MergeFrom(const RpbDelReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional uint32 rw = 3;
  inline bool has_rw() const;
  inline void clear_rw();
  static const int kRwFieldNumber = 3;
  inline ::google::protobuf::uint32 rw() const;
  inline void set_rw(::google::protobuf::uint32 value);
  
  // optional bytes vclock = 4;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 4;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  
  // optional uint32 r = 5;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 5;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);
  
  // optional uint32 w = 6;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 6;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);
  
  // optional uint32 pr = 7;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 7;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);
  
  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);
  
  // optional uint32 dw = 9;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 9;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:RpbDelReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_rw();
  inline void clear_has_rw();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_dw();
  inline void clear_has_dw();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::google::protobuf::uint32 rw_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 pr_;
  ::google::protobuf::uint32 pw_;
  ::google::protobuf::uint32 dw_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbDelReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListBucketsResp : public ::google::protobuf::Message {
 public:
  RpbListBucketsResp();
  virtual ~RpbListBucketsResp();
  
  RpbListBucketsResp(const RpbListBucketsResp& from);
  
  inline RpbListBucketsResp& operator=(const RpbListBucketsResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListBucketsResp& default_instance();
  
  void Swap(RpbListBucketsResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbListBucketsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListBucketsResp& from);
  void MergeFrom(const RpbListBucketsResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes buckets = 1;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 1;
  inline const ::std::string& buckets(int index) const;
  inline ::std::string* mutable_buckets(int index);
  inline void set_buckets(int index, const ::std::string& value);
  inline void set_buckets(int index, const char* value);
  inline void set_buckets(int index, const void* value, size_t size);
  inline ::std::string* add_buckets();
  inline void add_buckets(const ::std::string& value);
  inline void add_buckets(const char* value);
  inline void add_buckets(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_buckets();
  
  // @@protoc_insertion_point(class_scope:RpbListBucketsResp)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> buckets_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbListBucketsResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysReq : public ::google::protobuf::Message {
 public:
  RpbListKeysReq();
  virtual ~RpbListKeysReq();
  
  RpbListKeysReq(const RpbListKeysReq& from);
  
  inline RpbListKeysReq& operator=(const RpbListKeysReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysReq& default_instance();
  
  void Swap(RpbListKeysReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbListKeysReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysReq& from);
  void MergeFrom(const RpbListKeysReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // @@protoc_insertion_point(class_scope:RpbListKeysReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbListKeysReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysResp : public ::google::protobuf::Message {
 public:
  RpbListKeysResp();
  virtual ~RpbListKeysResp();
  
  RpbListKeysResp(const RpbListKeysResp& from);
  
  inline RpbListKeysResp& operator=(const RpbListKeysResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysResp& default_instance();
  
  void Swap(RpbListKeysResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbListKeysResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysResp& from);
  void MergeFrom(const RpbListKeysResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();
  
  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbListKeysResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  bool done_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbListKeysResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketReq : public ::google::protobuf::Message {
 public:
  RpbGetBucketReq();
  virtual ~RpbGetBucketReq();
  
  RpbGetBucketReq(const RpbGetBucketReq& from);
  
  inline RpbGetBucketReq& operator=(const RpbGetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketReq& default_instance();
  
  void Swap(RpbGetBucketReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketReq& from);
  void MergeFrom(const RpbGetBucketReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // @@protoc_insertion_point(class_scope:RpbGetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketResp : public ::google::protobuf::Message {
 public:
  RpbGetBucketResp();
  virtual ~RpbGetBucketResp();
  
  RpbGetBucketResp(const RpbGetBucketResp& from);
  
  inline RpbGetBucketResp& operator=(const RpbGetBucketResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketResp& default_instance();
  
  void Swap(RpbGetBucketResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetBucketResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketResp& from);
  void MergeFrom(const RpbGetBucketResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .RpbBucketProps props = 1;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 1;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  inline ::RpbBucketProps* release_props();
  
  // @@protoc_insertion_point(class_scope:RpbGetBucketResp)
 private:
  inline void set_has_props();
  inline void clear_has_props();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::RpbBucketProps* props_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetBucketResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetBucketReq : public ::google::protobuf::Message {
 public:
  RpbSetBucketReq();
  virtual ~RpbSetBucketReq();
  
  RpbSetBucketReq(const RpbSetBucketReq& from);
  
  inline RpbSetBucketReq& operator=(const RpbSetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetBucketReq& default_instance();
  
  void Swap(RpbSetBucketReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbSetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetBucketReq& from);
  void MergeFrom(const RpbSetBucketReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required .RpbBucketProps props = 2;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 2;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  inline ::RpbBucketProps* release_props();
  
  // @@protoc_insertion_point(class_scope:RpbSetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_props();
  inline void clear_has_props();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::RpbBucketProps* props_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbSetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedReq : public ::google::protobuf::Message {
 public:
  RpbMapRedReq();
  virtual ~RpbMapRedReq();
  
  RpbMapRedReq(const RpbMapRedReq& from);
  
  inline RpbMapRedReq& operator=(const RpbMapRedReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedReq& default_instance();
  
  void Swap(RpbMapRedReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbMapRedReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedReq& from);
  void MergeFrom(const RpbMapRedReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const void* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  
  // required bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  
  // @@protoc_insertion_point(class_scope:RpbMapRedReq)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* request_;
  ::std::string* content_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbMapRedReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedResp : public ::google::protobuf::Message {
 public:
  RpbMapRedResp();
  virtual ~RpbMapRedResp();
  
  RpbMapRedResp(const RpbMapRedResp& from);
  
  inline RpbMapRedResp& operator=(const RpbMapRedResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedResp& default_instance();
  
  void Swap(RpbMapRedResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbMapRedResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedResp& from);
  void MergeFrom(const RpbMapRedResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 phase = 1;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 1;
  inline ::google::protobuf::uint32 phase() const;
  inline void set_phase(::google::protobuf::uint32 value);
  
  // optional bytes response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  
  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbMapRedResp)
 private:
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_done();
  inline void clear_has_done();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_;
  ::google::protobuf::uint32 phase_;
  bool done_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbMapRedResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexReq : public ::google::protobuf::Message {
 public:
  RpbIndexReq();
  virtual ~RpbIndexReq();
  
  RpbIndexReq(const RpbIndexReq& from);
  
  inline RpbIndexReq& operator=(const RpbIndexReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexReq& default_instance();
  
  void Swap(RpbIndexReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbIndexReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexReq& from);
  void MergeFrom(const RpbIndexReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef RpbIndexReq_IndexQueryType IndexQueryType;
  static const IndexQueryType eq = RpbIndexReq_IndexQueryType_eq;
  static const IndexQueryType range = RpbIndexReq_IndexQueryType_range;
  static inline bool IndexQueryType_IsValid(int value) {
    return RpbIndexReq_IndexQueryType_IsValid(value);
  }
  static const IndexQueryType IndexQueryType_MIN =
    RpbIndexReq_IndexQueryType_IndexQueryType_MIN;
  static const IndexQueryType IndexQueryType_MAX =
    RpbIndexReq_IndexQueryType_IndexQueryType_MAX;
  static const int IndexQueryType_ARRAYSIZE =
    RpbIndexReq_IndexQueryType_IndexQueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IndexQueryType_descriptor() {
    return RpbIndexReq_IndexQueryType_descriptor();
  }
  static inline const ::std::string& IndexQueryType_Name(IndexQueryType value) {
    return RpbIndexReq_IndexQueryType_Name(value);
  }
  static inline bool IndexQueryType_Parse(const ::std::string& name,
      IndexQueryType* value) {
    return RpbIndexReq_IndexQueryType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required bytes index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline void set_index(const void* value, size_t size);
  inline ::std::string* mutable_index();
  inline ::std::string* release_index();
  
  // required .RpbIndexReq.IndexQueryType qtype = 3;
  inline bool has_qtype() const;
  inline void clear_qtype();
  static const int kQtypeFieldNumber = 3;
  inline ::RpbIndexReq_IndexQueryType qtype() const;
  inline void set_qtype(::RpbIndexReq_IndexQueryType value);
  
  // optional bytes key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional bytes range_min = 5;
  inline bool has_range_min() const;
  inline void clear_range_min();
  static const int kRangeMinFieldNumber = 5;
  inline const ::std::string& range_min() const;
  inline void set_range_min(const ::std::string& value);
  inline void set_range_min(const char* value);
  inline void set_range_min(const void* value, size_t size);
  inline ::std::string* mutable_range_min();
  inline ::std::string* release_range_min();
  
  // optional bytes range_max = 6;
  inline bool has_range_max() const;
  inline void clear_range_max();
  static const int kRangeMaxFieldNumber = 6;
  inline const ::std::string& range_max() const;
  inline void set_range_max(const ::std::string& value);
  inline void set_range_max(const char* value);
  inline void set_range_max(const void* value, size_t size);
  inline ::std::string* mutable_range_max();
  inline ::std::string* release_range_max();
  
  // @@protoc_insertion_point(class_scope:RpbIndexReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_qtype();
  inline void clear_has_qtype();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_range_min();
  inline void clear_has_range_min();
  inline void set_has_range_max();
  inline void clear_has_range_max();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* index_;
  ::std::string* key_;
  ::std::string* range_min_;
  ::std::string* range_max_;
  int qtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbIndexReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexResp : public ::google::protobuf::Message {
 public:
  RpbIndexResp();
  virtual ~RpbIndexResp();
  
  RpbIndexResp(const RpbIndexResp& from);
  
  inline RpbIndexResp& operator=(const RpbIndexResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexResp& default_instance();
  
  void Swap(RpbIndexResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbIndexResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexResp& from);
  void MergeFrom(const RpbIndexResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();
  
  // @@protoc_insertion_point(class_scope:RpbIndexResp)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbIndexResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbContent : public ::google::protobuf::Message {
 public:
  RpbContent();
  virtual ~RpbContent();
  
  RpbContent(const RpbContent& from);
  
  inline RpbContent& operator=(const RpbContent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbContent& default_instance();
  
  void Swap(RpbContent* other);
  
  // implements Message ----------------------------------------------
  
  RpbContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbContent& from);
  void MergeFrom(const RpbContent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // optional bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  
  // optional bytes charset = 3;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 3;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const void* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  
  // optional bytes content_encoding = 4;
  inline bool has_content_encoding() const;
  inline void clear_content_encoding();
  static const int kContentEncodingFieldNumber = 4;
  inline const ::std::string& content_encoding() const;
  inline void set_content_encoding(const ::std::string& value);
  inline void set_content_encoding(const char* value);
  inline void set_content_encoding(const void* value, size_t size);
  inline ::std::string* mutable_content_encoding();
  inline ::std::string* release_content_encoding();
  
  // optional bytes vtag = 5;
  inline bool has_vtag() const;
  inline void clear_vtag();
  static const int kVtagFieldNumber = 5;
  inline const ::std::string& vtag() const;
  inline void set_vtag(const ::std::string& value);
  inline void set_vtag(const char* value);
  inline void set_vtag(const void* value, size_t size);
  inline ::std::string* mutable_vtag();
  inline ::std::string* release_vtag();
  
  // repeated .RpbLink links = 6;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 6;
  inline const ::RpbLink& links(int index) const;
  inline ::RpbLink* mutable_links(int index);
  inline ::RpbLink* add_links();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
      links() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
      mutable_links();
  
  // optional uint32 last_mod = 7;
  inline bool has_last_mod() const;
  inline void clear_last_mod();
  static const int kLastModFieldNumber = 7;
  inline ::google::protobuf::uint32 last_mod() const;
  inline void set_last_mod(::google::protobuf::uint32 value);
  
  // optional uint32 last_mod_usecs = 8;
  inline bool has_last_mod_usecs() const;
  inline void clear_last_mod_usecs();
  static const int kLastModUsecsFieldNumber = 8;
  inline ::google::protobuf::uint32 last_mod_usecs() const;
  inline void set_last_mod_usecs(::google::protobuf::uint32 value);
  
  // repeated .RpbPair usermeta = 9;
  inline int usermeta_size() const;
  inline void clear_usermeta();
  static const int kUsermetaFieldNumber = 9;
  inline const ::RpbPair& usermeta(int index) const;
  inline ::RpbPair* mutable_usermeta(int index);
  inline ::RpbPair* add_usermeta();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      usermeta() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_usermeta();
  
  // repeated .RpbPair indexes = 10;
  inline int indexes_size() const;
  inline void clear_indexes();
  static const int kIndexesFieldNumber = 10;
  inline const ::RpbPair& indexes(int index) const;
  inline ::RpbPair* mutable_indexes(int index);
  inline ::RpbPair* add_indexes();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      indexes() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_indexes();
  
  // optional bool deleted = 11;
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 11;
  inline bool deleted() const;
  inline void set_deleted(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbContent)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_content_encoding();
  inline void clear_has_content_encoding();
  inline void set_has_vtag();
  inline void clear_has_vtag();
  inline void set_has_last_mod();
  inline void clear_has_last_mod();
  inline void set_has_last_mod_usecs();
  inline void clear_has_last_mod_usecs();
  inline void set_has_deleted();
  inline void clear_has_deleted();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  ::std::string* content_type_;
  ::std::string* charset_;
  ::std::string* content_encoding_;
  ::std::string* vtag_;
  ::google::protobuf::RepeatedPtrField< ::RpbLink > links_;
  ::google::protobuf::uint32 last_mod_;
  ::google::protobuf::uint32 last_mod_usecs_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > usermeta_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > indexes_;
  bool deleted_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbContent* default_instance_;
};
// -------------------------------------------------------------------

class RpbLink : public ::google::protobuf::Message {
 public:
  RpbLink();
  virtual ~RpbLink();
  
  RpbLink(const RpbLink& from);
  
  inline RpbLink& operator=(const RpbLink& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbLink& default_instance();
  
  void Swap(RpbLink* other);
  
  // implements Message ----------------------------------------------
  
  RpbLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbLink& from);
  void MergeFrom(const RpbLink& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional bytes tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // @@protoc_insertion_point(class_scope:RpbLink)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_tag();
  inline void clear_has_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbLink* default_instance_;
};
// -------------------------------------------------------------------

class RpbBucketProps : public ::google::protobuf::Message {
 public:
  RpbBucketProps();
  virtual ~RpbBucketProps();
  
  RpbBucketProps(const RpbBucketProps& from);
  
  inline RpbBucketProps& operator=(const RpbBucketProps& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbBucketProps& default_instance();
  
  void Swap(RpbBucketProps* other);
  
  // implements Message ----------------------------------------------
  
  RpbBucketProps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbBucketProps& from);
  void MergeFrom(const RpbBucketProps& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 n_val = 1;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 1;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);
  
  // optional bool allow_mult = 2;
  inline bool has_allow_mult() const;
  inline void clear_allow_mult();
  static const int kAllowMultFieldNumber = 2;
  inline bool allow_mult() const;
  inline void set_allow_mult(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbBucketProps)
 private:
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_allow_mult();
  inline void clear_has_allow_mult();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 n_val_;
  bool allow_mult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();
  
  void InitAsDefaultInstance();
  static RpbBucketProps* default_instance_;
};
// ===================================================================


// ===================================================================

// RpbGetClientIdResp

// required bytes client_id = 1;
inline bool RpbGetClientIdResp::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetClientIdResp::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetClientIdResp::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetClientIdResp::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbGetClientIdResp::client_id() const {
  return *client_id_;
}
inline void RpbGetClientIdResp::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbGetClientIdResp::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbGetClientIdResp::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetClientIdResp::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}
inline ::std::string* RpbGetClientIdResp::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbSetClientIdReq

// required bytes client_id = 1;
inline bool RpbSetClientIdReq::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetClientIdReq::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetClientIdReq::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetClientIdReq::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbSetClientIdReq::client_id() const {
  return *client_id_;
}
inline void RpbSetClientIdReq::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbSetClientIdReq::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbSetClientIdReq::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbSetClientIdReq::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}
inline ::std::string* RpbSetClientIdReq::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbGetReq

// required bytes bucket = 1;
inline bool RpbGetReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetReq::bucket() const {
  return *bucket_;
}
inline void RpbGetReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbGetReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes key = 2;
inline bool RpbGetReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbGetReq::key() const {
  return *key_;
}
inline void RpbGetReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbGetReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbGetReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbGetReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 r = 3;
inline bool RpbGetReq::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetReq::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbGetReq::r() const {
  return r_;
}
inline void RpbGetReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
}

// optional uint32 pr = 4;
inline bool RpbGetReq::has_pr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbGetReq::set_has_pr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbGetReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbGetReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbGetReq::pr() const {
  return pr_;
}
inline void RpbGetReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
}

// optional bool basic_quorum = 5;
inline bool RpbGetReq::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbGetReq::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbGetReq::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbGetReq::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool RpbGetReq::basic_quorum() const {
  return basic_quorum_;
}
inline void RpbGetReq::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
}

// optional bool notfound_ok = 6;
inline bool RpbGetReq::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbGetReq::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbGetReq::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbGetReq::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool RpbGetReq::notfound_ok() const {
  return notfound_ok_;
}
inline void RpbGetReq::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
}

// optional bytes if_modified = 7;
inline bool RpbGetReq::has_if_modified() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbGetReq::set_has_if_modified() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbGetReq::clear_has_if_modified() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbGetReq::clear_if_modified() {
  if (if_modified_ != &::google::protobuf::internal::kEmptyString) {
    if_modified_->clear();
  }
  clear_has_if_modified();
}
inline const ::std::string& RpbGetReq::if_modified() const {
  return *if_modified_;
}
inline void RpbGetReq::set_if_modified(const ::std::string& value) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(value);
}
inline void RpbGetReq::set_if_modified(const char* value) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(value);
}
inline void RpbGetReq::set_if_modified(const void* value, size_t size) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_if_modified() {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    if_modified_ = new ::std::string;
  }
  return if_modified_;
}
inline ::std::string* RpbGetReq::release_if_modified() {
  clear_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = if_modified_;
    if_modified_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool head = 8;
inline bool RpbGetReq::has_head() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbGetReq::set_has_head() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbGetReq::clear_has_head() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbGetReq::clear_head() {
  head_ = false;
  clear_has_head();
}
inline bool RpbGetReq::head() const {
  return head_;
}
inline void RpbGetReq::set_head(bool value) {
  set_has_head();
  head_ = value;
}

// optional bool deletedvclock = 9;
inline bool RpbGetReq::has_deletedvclock() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbGetReq::set_has_deletedvclock() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbGetReq::clear_has_deletedvclock() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbGetReq::clear_deletedvclock() {
  deletedvclock_ = false;
  clear_has_deletedvclock();
}
inline bool RpbGetReq::deletedvclock() const {
  return deletedvclock_;
}
inline void RpbGetReq::set_deletedvclock(bool value) {
  set_has_deletedvclock();
  deletedvclock_ = value;
}

// -------------------------------------------------------------------

// RpbGetResp

// repeated .RpbContent content = 1;
inline int RpbGetResp::content_size() const {
  return content_.size();
}
inline void RpbGetResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbGetResp::content(int index) const {
  return content_.Get(index);
}
inline ::RpbContent* RpbGetResp::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::RpbContent* RpbGetResp::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbGetResp::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbGetResp::mutable_content() {
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbGetResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbGetResp::vclock() const {
  return *vclock_;
}
inline void RpbGetResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbGetResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbGetResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbGetResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool unchanged = 3;
inline bool RpbGetResp::has_unchanged() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetResp::set_has_unchanged() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetResp::clear_has_unchanged() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetResp::clear_unchanged() {
  unchanged_ = false;
  clear_has_unchanged();
}
inline bool RpbGetResp::unchanged() const {
  return unchanged_;
}
inline void RpbGetResp::set_unchanged(bool value) {
  set_has_unchanged();
  unchanged_ = value;
}

// -------------------------------------------------------------------

// RpbPutReq

// required bytes bucket = 1;
inline bool RpbPutReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbPutReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbPutReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbPutReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbPutReq::bucket() const {
  return *bucket_;
}
inline void RpbPutReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbPutReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbPutReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbPutReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes key = 2;
inline bool RpbPutReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutReq::key() const {
  return *key_;
}
inline void RpbPutReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbPutReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes vclock = 3;
inline bool RpbPutReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutReq::vclock() const {
  return *vclock_;
}
inline void RpbPutReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbPutReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .RpbContent content = 4;
inline bool RpbPutReq::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbPutReq::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbPutReq::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbPutReq::clear_content() {
  if (content_ != NULL) content_->::RpbContent::Clear();
  clear_has_content();
}
inline const ::RpbContent& RpbPutReq::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::RpbContent* RpbPutReq::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::RpbContent;
  return content_;
}
inline ::RpbContent* RpbPutReq::release_content() {
  clear_has_content();
  ::RpbContent* temp = content_;
  content_ = NULL;
  return temp;
}

// optional uint32 w = 5;
inline bool RpbPutReq::has_w() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbPutReq::set_has_w() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbPutReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbPutReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbPutReq::w() const {
  return w_;
}
inline void RpbPutReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
}

// optional uint32 dw = 6;
inline bool RpbPutReq::has_dw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbPutReq::set_has_dw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbPutReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbPutReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbPutReq::dw() const {
  return dw_;
}
inline void RpbPutReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
}

// optional bool return_body = 7;
inline bool RpbPutReq::has_return_body() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbPutReq::set_has_return_body() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbPutReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbPutReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool RpbPutReq::return_body() const {
  return return_body_;
}
inline void RpbPutReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
}

// optional uint32 pw = 8;
inline bool RpbPutReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbPutReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbPutReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbPutReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbPutReq::pw() const {
  return pw_;
}
inline void RpbPutReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
}

// optional bool if_not_modified = 9;
inline bool RpbPutReq::has_if_not_modified() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbPutReq::set_has_if_not_modified() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbPutReq::clear_has_if_not_modified() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbPutReq::clear_if_not_modified() {
  if_not_modified_ = false;
  clear_has_if_not_modified();
}
inline bool RpbPutReq::if_not_modified() const {
  return if_not_modified_;
}
inline void RpbPutReq::set_if_not_modified(bool value) {
  set_has_if_not_modified();
  if_not_modified_ = value;
}

// optional bool if_none_match = 10;
inline bool RpbPutReq::has_if_none_match() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbPutReq::set_has_if_none_match() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbPutReq::clear_has_if_none_match() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbPutReq::clear_if_none_match() {
  if_none_match_ = false;
  clear_has_if_none_match();
}
inline bool RpbPutReq::if_none_match() const {
  return if_none_match_;
}
inline void RpbPutReq::set_if_none_match(bool value) {
  set_has_if_none_match();
  if_none_match_ = value;
}

// optional bool return_head = 11;
inline bool RpbPutReq::has_return_head() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbPutReq::set_has_return_head() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbPutReq::clear_has_return_head() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbPutReq::clear_return_head() {
  return_head_ = false;
  clear_has_return_head();
}
inline bool RpbPutReq::return_head() const {
  return return_head_;
}
inline void RpbPutReq::set_return_head(bool value) {
  set_has_return_head();
  return_head_ = value;
}

// -------------------------------------------------------------------

// RpbPutResp

// repeated .RpbContent content = 1;
inline int RpbPutResp::content_size() const {
  return content_.size();
}
inline void RpbPutResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbPutResp::content(int index) const {
  return content_.Get(index);
}
inline ::RpbContent* RpbPutResp::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::RpbContent* RpbPutResp::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbPutResp::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbPutResp::mutable_content() {
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbPutResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutResp::vclock() const {
  return *vclock_;
}
inline void RpbPutResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbPutResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes key = 3;
inline bool RpbPutResp::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutResp::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutResp::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutResp::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutResp::key() const {
  return *key_;
}
inline void RpbPutResp::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutResp::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutResp::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutResp::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbPutResp::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbDelReq

// required bytes bucket = 1;
inline bool RpbDelReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbDelReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbDelReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbDelReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbDelReq::bucket() const {
  return *bucket_;
}
inline void RpbDelReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbDelReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbDelReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbDelReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes key = 2;
inline bool RpbDelReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbDelReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbDelReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbDelReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbDelReq::key() const {
  return *key_;
}
inline void RpbDelReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbDelReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbDelReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbDelReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 rw = 3;
inline bool RpbDelReq::has_rw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbDelReq::set_has_rw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbDelReq::clear_has_rw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbDelReq::clear_rw() {
  rw_ = 0u;
  clear_has_rw();
}
inline ::google::protobuf::uint32 RpbDelReq::rw() const {
  return rw_;
}
inline void RpbDelReq::set_rw(::google::protobuf::uint32 value) {
  set_has_rw();
  rw_ = value;
}

// optional bytes vclock = 4;
inline bool RpbDelReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbDelReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbDelReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbDelReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbDelReq::vclock() const {
  return *vclock_;
}
inline void RpbDelReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbDelReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbDelReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbDelReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 r = 5;
inline bool RpbDelReq::has_r() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbDelReq::set_has_r() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbDelReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbDelReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbDelReq::r() const {
  return r_;
}
inline void RpbDelReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
}

// optional uint32 w = 6;
inline bool RpbDelReq::has_w() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbDelReq::set_has_w() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbDelReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbDelReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbDelReq::w() const {
  return w_;
}
inline void RpbDelReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
}

// optional uint32 pr = 7;
inline bool RpbDelReq::has_pr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbDelReq::set_has_pr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbDelReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbDelReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbDelReq::pr() const {
  return pr_;
}
inline void RpbDelReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
}

// optional uint32 pw = 8;
inline bool RpbDelReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbDelReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbDelReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbDelReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbDelReq::pw() const {
  return pw_;
}
inline void RpbDelReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
}

// optional uint32 dw = 9;
inline bool RpbDelReq::has_dw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbDelReq::set_has_dw() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbDelReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbDelReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbDelReq::dw() const {
  return dw_;
}
inline void RpbDelReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
}

// -------------------------------------------------------------------

// RpbListBucketsResp

// repeated bytes buckets = 1;
inline int RpbListBucketsResp::buckets_size() const {
  return buckets_.size();
}
inline void RpbListBucketsResp::clear_buckets() {
  buckets_.Clear();
}
inline const ::std::string& RpbListBucketsResp::buckets(int index) const {
  return buckets_.Get(index);
}
inline ::std::string* RpbListBucketsResp::mutable_buckets(int index) {
  return buckets_.Mutable(index);
}
inline void RpbListBucketsResp::set_buckets(int index, const ::std::string& value) {
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const char* value) {
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const void* value, size_t size) {
  buckets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListBucketsResp::add_buckets() {
  return buckets_.Add();
}
inline void RpbListBucketsResp::add_buckets(const ::std::string& value) {
  buckets_.Add()->assign(value);
}
inline void RpbListBucketsResp::add_buckets(const char* value) {
  buckets_.Add()->assign(value);
}
inline void RpbListBucketsResp::add_buckets(const void* value, size_t size) {
  buckets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListBucketsResp::buckets() const {
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListBucketsResp::mutable_buckets() {
  return &buckets_;
}

// -------------------------------------------------------------------

// RpbListKeysReq

// required bytes bucket = 1;
inline bool RpbListKeysReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbListKeysReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbListKeysReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbListKeysReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbListKeysReq::bucket() const {
  return *bucket_;
}
inline void RpbListKeysReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbListKeysReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbListKeysReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListKeysReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbListKeysReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbListKeysResp

// repeated bytes keys = 1;
inline int RpbListKeysResp::keys_size() const {
  return keys_.size();
}
inline void RpbListKeysResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbListKeysResp::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* RpbListKeysResp::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void RpbListKeysResp::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListKeysResp::add_keys() {
  return keys_.Add();
}
inline void RpbListKeysResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void RpbListKeysResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void RpbListKeysResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListKeysResp::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListKeysResp::mutable_keys() {
  return &keys_;
}

// optional bool done = 2;
inline bool RpbListKeysResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListKeysResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListKeysResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListKeysResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbListKeysResp::done() const {
  return done_;
}
inline void RpbListKeysResp::set_done(bool value) {
  set_has_done();
  done_ = value;
}

// -------------------------------------------------------------------

// RpbGetBucketReq

// required bytes bucket = 1;
inline bool RpbGetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetBucketReq::bucket() const {
  return *bucket_;
}
inline void RpbGetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbGetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbGetBucketResp

// required .RpbBucketProps props = 1;
inline bool RpbGetBucketResp::has_props() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketResp::set_has_props() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketResp::clear_has_props() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketResp::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::RpbBucketProps& RpbGetBucketResp::props() const {
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbGetBucketResp::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  return props_;
}
inline ::RpbBucketProps* RpbGetBucketResp::release_props() {
  clear_has_props();
  ::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RpbSetBucketReq

// required bytes bucket = 1;
inline bool RpbSetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbSetBucketReq::bucket() const {
  return *bucket_;
}
inline void RpbSetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbSetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbSetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbSetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbSetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .RpbBucketProps props = 2;
inline bool RpbSetBucketReq::has_props() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbSetBucketReq::set_has_props() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbSetBucketReq::clear_has_props() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbSetBucketReq::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::RpbBucketProps& RpbSetBucketReq::props() const {
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbSetBucketReq::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  return props_;
}
inline ::RpbBucketProps* RpbSetBucketReq::release_props() {
  clear_has_props();
  ::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RpbMapRedReq

// required bytes request = 1;
inline bool RpbMapRedReq::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedReq::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedReq::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedReq::clear_request() {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& RpbMapRedReq::request() const {
  return *request_;
}
inline void RpbMapRedReq::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void RpbMapRedReq::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void RpbMapRedReq::set_request(const void* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedReq::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  return request_;
}
inline ::std::string* RpbMapRedReq::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes content_type = 2;
inline bool RpbMapRedReq::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedReq::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedReq::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedReq::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::kEmptyString) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbMapRedReq::content_type() const {
  return *content_type_;
}
inline void RpbMapRedReq::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbMapRedReq::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbMapRedReq::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedReq::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  return content_type_;
}
inline ::std::string* RpbMapRedReq::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbMapRedResp

// optional uint32 phase = 1;
inline bool RpbMapRedResp::has_phase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedResp::set_has_phase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedResp::clear_has_phase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedResp::clear_phase() {
  phase_ = 0u;
  clear_has_phase();
}
inline ::google::protobuf::uint32 RpbMapRedResp::phase() const {
  return phase_;
}
inline void RpbMapRedResp::set_phase(::google::protobuf::uint32 value) {
  set_has_phase();
  phase_ = value;
}

// optional bytes response = 2;
inline bool RpbMapRedResp::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedResp::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedResp::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedResp::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& RpbMapRedResp::response() const {
  return *response_;
}
inline void RpbMapRedResp::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RpbMapRedResp::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RpbMapRedResp::set_response(const void* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedResp::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* RpbMapRedResp::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool done = 3;
inline bool RpbMapRedResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbMapRedResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbMapRedResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbMapRedResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbMapRedResp::done() const {
  return done_;
}
inline void RpbMapRedResp::set_done(bool value) {
  set_has_done();
  done_ = value;
}

// -------------------------------------------------------------------

// RpbIndexReq

// required bytes bucket = 1;
inline bool RpbIndexReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbIndexReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbIndexReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbIndexReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbIndexReq::bucket() const {
  return *bucket_;
}
inline void RpbIndexReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbIndexReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbIndexReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbIndexReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbIndexReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes index = 2;
inline bool RpbIndexReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbIndexReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbIndexReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbIndexReq::clear_index() {
  if (index_ != &::google::protobuf::internal::kEmptyString) {
    index_->clear();
  }
  clear_has_index();
}
inline const ::std::string& RpbIndexReq::index() const {
  return *index_;
}
inline void RpbIndexReq::set_index(const ::std::string& value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void RpbIndexReq::set_index(const char* value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void RpbIndexReq::set_index(const void* value, size_t size) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbIndexReq::mutable_index() {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  return index_;
}
inline ::std::string* RpbIndexReq::release_index() {
  clear_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index_;
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .RpbIndexReq.IndexQueryType qtype = 3;
inline bool RpbIndexReq::has_qtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbIndexReq::set_has_qtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbIndexReq::clear_has_qtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbIndexReq::clear_qtype() {
  qtype_ = 0;
  clear_has_qtype();
}
inline ::RpbIndexReq_IndexQueryType RpbIndexReq::qtype() const {
  return static_cast< ::RpbIndexReq_IndexQueryType >(qtype_);
}
inline void RpbIndexReq::set_qtype(::RpbIndexReq_IndexQueryType value) {
  GOOGLE_DCHECK(::RpbIndexReq_IndexQueryType_IsValid(value));
  set_has_qtype();
  qtype_ = value;
}

// optional bytes key = 4;
inline bool RpbIndexReq::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbIndexReq::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbIndexReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbIndexReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbIndexReq::key() const {
  return *key_;
}
inline void RpbIndexReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbIndexReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbIndexReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbIndexReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbIndexReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes range_min = 5;
inline bool RpbIndexReq::has_range_min() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbIndexReq::set_has_range_min() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbIndexReq::clear_has_range_min() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbIndexReq::clear_range_min() {
  if (range_min_ != &::google::protobuf::internal::kEmptyString) {
    range_min_->clear();
  }
  clear_has_range_min();
}
inline const ::std::string& RpbIndexReq::range_min() const {
  return *range_min_;
}
inline void RpbIndexReq::set_range_min(const ::std::string& value) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::kEmptyString) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(value);
}
inline void RpbIndexReq::set_range_min(const char* value) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::kEmptyString) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(value);
}
inline void RpbIndexReq::set_range_min(const void* value, size_t size) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::kEmptyString) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbIndexReq::mutable_range_min() {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::kEmptyString) {
    range_min_ = new ::std::string;
  }
  return range_min_;
}
inline ::std::string* RpbIndexReq::release_range_min() {
  clear_has_range_min();
  if (range_min_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = range_min_;
    range_min_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes range_max = 6;
inline bool RpbIndexReq::has_range_max() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbIndexReq::set_has_range_max() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbIndexReq::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbIndexReq::clear_range_max() {
  if (range_max_ != &::google::protobuf::internal::kEmptyString) {
    range_max_->clear();
  }
  clear_has_range_max();
}
inline const ::std::string& RpbIndexReq::range_max() const {
  return *range_max_;
}
inline void RpbIndexReq::set_range_max(const ::std::string& value) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::kEmptyString) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(value);
}
inline void RpbIndexReq::set_range_max(const char* value) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::kEmptyString) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(value);
}
inline void RpbIndexReq::set_range_max(const void* value, size_t size) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::kEmptyString) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbIndexReq::mutable_range_max() {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::kEmptyString) {
    range_max_ = new ::std::string;
  }
  return range_max_;
}
inline ::std::string* RpbIndexReq::release_range_max() {
  clear_has_range_max();
  if (range_max_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = range_max_;
    range_max_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbIndexResp

// repeated bytes keys = 1;
inline int RpbIndexResp::keys_size() const {
  return keys_.size();
}
inline void RpbIndexResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbIndexResp::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* RpbIndexResp::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void RpbIndexResp::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbIndexResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbIndexResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbIndexResp::add_keys() {
  return keys_.Add();
}
inline void RpbIndexResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void RpbIndexResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void RpbIndexResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbIndexResp::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbIndexResp::mutable_keys() {
  return &keys_;
}

// -------------------------------------------------------------------

// RpbContent

// required bytes value = 1;
inline bool RpbContent::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbContent::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbContent::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbContent::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RpbContent::value() const {
  return *value_;
}
inline void RpbContent::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbContent::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbContent::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* RpbContent::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes content_type = 2;
inline bool RpbContent::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbContent::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbContent::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbContent::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::kEmptyString) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbContent::content_type() const {
  return *content_type_;
}
inline void RpbContent::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbContent::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbContent::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  return content_type_;
}
inline ::std::string* RpbContent::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes charset = 3;
inline bool RpbContent::has_charset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbContent::set_has_charset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbContent::clear_has_charset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbContent::clear_charset() {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& RpbContent::charset() const {
  return *charset_;
}
inline void RpbContent::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RpbContent::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RpbContent::set_charset(const void* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  return charset_;
}
inline ::std::string* RpbContent::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes content_encoding = 4;
inline bool RpbContent::has_content_encoding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbContent::set_has_content_encoding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbContent::clear_has_content_encoding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbContent::clear_content_encoding() {
  if (content_encoding_ != &::google::protobuf::internal::kEmptyString) {
    content_encoding_->clear();
  }
  clear_has_content_encoding();
}
inline const ::std::string& RpbContent::content_encoding() const {
  return *content_encoding_;
}
inline void RpbContent::set_content_encoding(const ::std::string& value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
}
inline void RpbContent::set_content_encoding(const char* value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
}
inline void RpbContent::set_content_encoding(const void* value, size_t size) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_content_encoding() {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  return content_encoding_;
}
inline ::std::string* RpbContent::release_content_encoding() {
  clear_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_encoding_;
    content_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes vtag = 5;
inline bool RpbContent::has_vtag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbContent::set_has_vtag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbContent::clear_has_vtag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbContent::clear_vtag() {
  if (vtag_ != &::google::protobuf::internal::kEmptyString) {
    vtag_->clear();
  }
  clear_has_vtag();
}
inline const ::std::string& RpbContent::vtag() const {
  return *vtag_;
}
inline void RpbContent::set_vtag(const ::std::string& value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
}
inline void RpbContent::set_vtag(const char* value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
}
inline void RpbContent::set_vtag(const void* value, size_t size) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_vtag() {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  return vtag_;
}
inline ::std::string* RpbContent::release_vtag() {
  clear_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vtag_;
    vtag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .RpbLink links = 6;
inline int RpbContent::links_size() const {
  return links_.size();
}
inline void RpbContent::clear_links() {
  links_.Clear();
}
inline const ::RpbLink& RpbContent::links(int index) const {
  return links_.Get(index);
}
inline ::RpbLink* RpbContent::mutable_links(int index) {
  return links_.Mutable(index);
}
inline ::RpbLink* RpbContent::add_links() {
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
RpbContent::links() const {
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
RpbContent::mutable_links() {
  return &links_;
}

// optional uint32 last_mod = 7;
inline bool RpbContent::has_last_mod() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbContent::set_has_last_mod() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbContent::clear_has_last_mod() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbContent::clear_last_mod() {
  last_mod_ = 0u;
  clear_has_last_mod();
}
inline ::google::protobuf::uint32 RpbContent::last_mod() const {
  return last_mod_;
}
inline void RpbContent::set_last_mod(::google::protobuf::uint32 value) {
  set_has_last_mod();
  last_mod_ = value;
}

// optional uint32 last_mod_usecs = 8;
inline bool RpbContent::has_last_mod_usecs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbContent::set_has_last_mod_usecs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbContent::clear_has_last_mod_usecs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbContent::clear_last_mod_usecs() {
  last_mod_usecs_ = 0u;
  clear_has_last_mod_usecs();
}
inline ::google::protobuf::uint32 RpbContent::last_mod_usecs() const {
  return last_mod_usecs_;
}
inline void RpbContent::set_last_mod_usecs(::google::protobuf::uint32 value) {
  set_has_last_mod_usecs();
  last_mod_usecs_ = value;
}

// repeated .RpbPair usermeta = 9;
inline int RpbContent::usermeta_size() const {
  return usermeta_.size();
}
inline void RpbContent::clear_usermeta() {
  usermeta_.Clear();
}
inline const ::RpbPair& RpbContent::usermeta(int index) const {
  return usermeta_.Get(index);
}
inline ::RpbPair* RpbContent::mutable_usermeta(int index) {
  return usermeta_.Mutable(index);
}
inline ::RpbPair* RpbContent::add_usermeta() {
  return usermeta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbContent::usermeta() const {
  return usermeta_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbContent::mutable_usermeta() {
  return &usermeta_;
}

// repeated .RpbPair indexes = 10;
inline int RpbContent::indexes_size() const {
  return indexes_.size();
}
inline void RpbContent::clear_indexes() {
  indexes_.Clear();
}
inline const ::RpbPair& RpbContent::indexes(int index) const {
  return indexes_.Get(index);
}
inline ::RpbPair* RpbContent::mutable_indexes(int index) {
  return indexes_.Mutable(index);
}
inline ::RpbPair* RpbContent::add_indexes() {
  return indexes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbContent::indexes() const {
  return indexes_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbContent::mutable_indexes() {
  return &indexes_;
}

// optional bool deleted = 11;
inline bool RpbContent::has_deleted() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbContent::set_has_deleted() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbContent::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbContent::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool RpbContent::deleted() const {
  return deleted_;
}
inline void RpbContent::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
}

// -------------------------------------------------------------------

// RpbLink

// optional bytes bucket = 1;
inline bool RpbLink::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbLink::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbLink::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbLink::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbLink::bucket() const {
  return *bucket_;
}
inline void RpbLink::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbLink::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbLink::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbLink::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes key = 2;
inline bool RpbLink::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbLink::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbLink::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbLink::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbLink::key() const {
  return *key_;
}
inline void RpbLink::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbLink::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbLink::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbLink::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes tag = 3;
inline bool RpbLink::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbLink::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbLink::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbLink::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& RpbLink::tag() const {
  return *tag_;
}
inline void RpbLink::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void RpbLink::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void RpbLink::set_tag(const void* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* RpbLink::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbBucketProps

// optional uint32 n_val = 1;
inline bool RpbBucketProps::has_n_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbBucketProps::set_has_n_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbBucketProps::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbBucketProps::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbBucketProps::n_val() const {
  return n_val_;
}
inline void RpbBucketProps::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
}

// optional bool allow_mult = 2;
inline bool RpbBucketProps::has_allow_mult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbBucketProps::set_has_allow_mult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbBucketProps::clear_has_allow_mult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbBucketProps::clear_allow_mult() {
  allow_mult_ = false;
  clear_has_allow_mult();
}
inline bool RpbBucketProps::allow_mult() const {
  return allow_mult_;
}
inline void RpbBucketProps::set_allow_mult(bool value) {
  set_has_allow_mult();
  allow_mult_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RpbIndexReq_IndexQueryType>() {
  return ::RpbIndexReq_IndexQueryType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_riak_5fkv_2eproto__INCLUDED
